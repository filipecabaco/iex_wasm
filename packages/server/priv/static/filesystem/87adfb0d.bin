;; generated automatically.  DO NOT EDIT
#!no-fold-case
(define-module gauche.generator (use gauche.sequence) (use gauche.partcont) (export list->generator vector->generator reverse-vector->generator string->generator uvector->generator bits->generator reverse-bits->generator file->generator file->sexp-generator file->char-generator file->line-generator file->byte-generator port->sexp-generator port->char-generator port->line-generator port->byte-generator x->generator generate generator->list generator->reverse-list generator->vector generator->vector! generator->string generator->uvector generator->uvector! generator->bytevector generator->bytevector! generator-any generator-every generator-unfold generator-count generator-map->list null-generator gcons* gappend gflatten gconcatenate gmerge ggroup circular-generator gunfold giterate giterate1 giota grange gindex gselect ginterval gmap gmap-accum gfilter gremove gdelete gdelete-neighbor-dups gfilter-map gstate-filter gbuffer-filter gtake gtake* gdrop gtake-while gdrop-while grxmatch gslices glet* glet1 do-generator generator make-iota-generator make-range-generator make-coroutine-generator bytevector->generator make-for-each-generator make-unfold-generator gcombine))
(select-module gauche.generator)
(dynamic-load "gauche--generator")
(define-syntax glet* (syntax-rules () ((_ () body body2 ...) (begin body body2 ...)) ((_ ((var gen-expr) more-bindings ...) . body) (let1 var gen-expr (if (eof-object? var) var (glet* (more-bindings ...) . body)))) ((_ ((gen-expr) more-bindings ...) . body) (let1 var gen-expr (if (eof-object? var) var (glet* (more-bindings ...) . body))))))
(define-syntax glet1 (syntax-rules () ((_ var gen-expr body body2 ...) (let1 var gen-expr (if (eof-object? var) var (begin body body2 ...))))))
(define-syntax do-generator (syntax-rules () ((_ (var generator-expr) body ...) (let1 g generator-expr (let loop () (glet1 var (g) body ... (loop)))))))
